# September 2024
- Working on a platformer prototype
	- Start
		- Need to ideate on the design more
		- core idea is to play around with large complex engaging room design
		- implementation-wise, need to be able to move the character in "3D"
		- need to give the character the ability to move up and down
			- and keep the ability to jump? will need to add a z coordinate
			- this means we'll need to write `Vec3` 
	- Design
		- make a 3x3 grid of platforms at N different elevations
		- should be able to jump up a delta of 1, or down any number
		- this creates a digraph, and possible easy backtracking, esp. if we add powerups that increase crossable distances
- Engine improvements
	- selected scene is remembered across reloads
	- using `ui.label("\n")` as an alias for `ui.line()` cuts LOC in half
- [[Eyeball Generator]]
	- Design
		- simple eye consists of 3 shapes: cornea, iris, eyebrow
		- cornea drawn via testing if point is between upper and lower curve
		- sliders to tweak params
	- Made EyeGenScene, copied from TexGenScene
		- we'll want to share the uiParams logic, probably factor out into a uilib.h
		- for now just hardcode params to get something working
		- "programmatically creating a texture" is something we're probably going to want to do more of; interfacing directly with SDL_CreateRGBSurface is dubious
		- most of the application does not want to think in SDL-shaped terms, it's an abstraction-layer mismatch
	- Need to enable different shapes
		- idea is to turn the space between both eye corners into a UV coordinate system then do simple math from there
	- maybe save params across reloads?
- Incremental Compilation
	- we're taking 4.2s per rebuild, it's probably time to split things up into individual object files, which *should* speed things up considerably in the common case where we're just iterating on a single scene
	- ideally everything Just Works and is totally transparent to the user (me), meaning I don't have to manually set up build configuration/dependencies - though we can hardcode things for now and automate those as a v2
		- in theory we can just scan each file for `#include`s and build a dependency graph that way
	- before anything we'll need to split .h into .h and .cpp
		- common.cpp being used in both build-scythe.sh and builder.h is a big ole red flag
		- ideally we're not duplicating the subset of our build info that scythe.cpp needs
		- for now just hacking stuff into eyeGenScene.cpp to avoid making more .o files until stuff works...
- revamp build system
	- unify build logic between scythe.exe, game.dll, and test.exe
	- build.py with different arguments for build-and-run vs test
- Scriptable Particle Effects
	- MVP quick turnaround build stuff: build.py watches one file, scythe watches the rest, change scythe to separate rebuild and reload, test dll for modifications directly
	- aggravating! so that's mostly done, except for the eentsy tiny detail that we need a lockfile; the `modified` field (seems to) get updated at the *start* of writing out the .dll, so it fails to load
	- aight that worked well enough, calling that sufficiently functional
	- one last nice touch would be to add a timer so we can see how much time we're saving and feel good about ourselves - buildtime is a metric I care about, so measure it
- Build tree generation
	- Image data refactor
		- Extract common code to manipulate Textures
	- start from program.cpp, scan for includes, detect object files that correspond to headers
- Asset auto-reloading
